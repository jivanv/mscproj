class Nanosatellite;
class Battery;
class Camera;
class PayloadState;
class Window;
class SolarPanel;
class SolarPanelState;
class Memory;
class Transmitter;
class RadiationMonitor;

class Nanosatellite 
{
	Battery mainBattery;
	Memory memory;
	Camera camera;
	SolarPanel panel;
	Transmitter transmitter;
	RadiationMonitor rm;
		    
	Nanosatellite(Battery b, Memory m)
	{
    	mainBattery = b;
    	memory = m;
        camera = new Camera(this);
        panel = new SolarPanel(this);
        transmitter = new Transmitter(this);
        rm = new RadiationMonitor(this);
  	}
  	  	
	action takePhoto {}
	action chargeBattery {}
	action downlinkData {}
	action measureRadiation {}
}

// The battery

class Battery extends Reservoir
{
    string profileType;
    
    // ic = initial capacity, min, max
	Battery(float ic, float min, float max)
	{
		super(ic, min, max);
		profileType="IncrementalFlowProfile";
	}
}

// The memory

class Memory extends Reservoir
{
    string profileType;
    
    // ic = initial capacity, min, max
	Memory(float ic, float min, float max)
	{
		super(ic, min, max);
		profileType="IncrementalFlowProfile";
	}
}

// Time window for availability

class Window extends Timeline
{
    predicate Available {}
}

class PayloadState extends Timeline
{
	predicate On {}
	predicate Off {}
	predicate poweringUp {}
	predicate poweringDown {}	
}

class Camera
{
    Nanosatellite nanosat;
	PayloadState state;
	Window window;
	
	Camera(Nanosatellite n)
	{
		nanosat = n;
	    state = new PayloadState();
	    window = new Window();
	}
		
	action takePhoto{
    	eq(1, duration);
	}
	
	action turnOn{
	    eq(2, duration);
	}
	
	action turnOff{
	    eq(2, duration);
	}
	
	action consumePowerWhileOn {
	    eq(1, duration);
	}
}

class SolarPanelState extends Timeline
{
	predicate Charging {}
}

class SolarPanel
{
    Nanosatellite nanosat;
	SolarPanelState state;
	Window window;
	
	SolarPanel(Nanosatellite n)
	{
		nanosat = n;
	    state = new SolarPanelState();
	    window = new Window();
	}
	
	action chargeBattery {
	    eq(1, duration);
	}
}

class Transmitter
{
    Nanosatellite nanosat;
    Window window;
    
    Transmitter(Nanosatellite n)
    {
        nanosat = n;
        window = new Window();
    }
    
    action downlinkData{
        eq(1, duration);
    }
}

class RadiationMonitor
{
    Nanosatellite nanosat;
	PayloadState state;
	Window window;
	
	RadiationMonitor(Nanosatellite n)
	{
		nanosat = n;
	    state = new PayloadState();
	    window = new Window();
	}
		
	action measureRadiation{
    	eq(8, duration);
	}
	
	action turnOn{
	    eq(2, duration);
	}
	
	action turnOff{
	    eq(2, duration);
	}
	
	action consumePowerWhileOn {
	    eq(1, duration);
	}
}

// Actions

Nanosatellite::takePhoto
{
	equals(object.camera.takePhoto);
}

Nanosatellite::chargeBattery
{
   equals(object.panel.chargeBattery);
}

Nanosatellite::downlinkData
{
    equals(object.transmitter.downlinkData);
}

Nanosatellite::measureRadiation
{
    equals(object.rm.measureRadiation);
}

Camera::takePhoto
{
    contained_by(condition object.state.On);
    contained_by(condition object.window.Available);
    starts(effect object.nanosat.memory.produce data);
    eq(data.quantity, 50);
}

Camera::turnOn
{
    before(object.takePhoto);
    contained_by(condition object.window.Available);
	met_by(condition object.state.Off);
	equals(effect object.state.poweringUp);
	meets(effect object.state.On);
}

Camera::turnOff
{
    after(object.takePhoto);
    contained_by(condition object.window.Available);
	met_by(condition object.state.On);
	equals(effect object.state.poweringDown);
	meets(effect object.state.Off);
}

Camera::consumePowerWhileOn
{
    contained_by(object.state.On);
    bool continueLoopC;
    if(continueLoopC) {
        meets(effect object.consumePowerWhileOn next);
        next.end <= 15;
        starts(effect object.nanosat.mainBattery.consume power);
        mulEq(duration, 6, power.quantity);
    }
}

SolarPanel::chargeBattery
{
    contained_by(condition object.window.Available);
    equals(effect object.state.Charging);
  	bool continueLoopB;
    if(continueLoopB) {
        meets(effect object.chargeBattery next);
        next.end <= 50;
        starts(effect object.nanosat.mainBattery.produce power);
        mulEq(duration, 3, power.quantity);
    }
}

Transmitter::downlinkData
{
    contained_by(condition object.window.Available);
    bool continueLoop;
    if(continueLoop) {
        meets(effect object.downlinkData next);
        next.end <= 90;
        starts(effect object.nanosat.memory.consume data);
        mulEq(duration, 10, data.quantity);
        
        // downlinking also uses battery
        
        starts(effect object.nanosat.mainBattery.consume consumption);
        mulEq(duration, 2, consumption.quantity);
    }
}

RadiationMonitor::measureRadiation
{
    contained_by(condition object.state.On);
    contained_by(condition object.window.Available);
    starts(effect object.nanosat.memory.produce data);
    eq(data.quantity, 50);
}

RadiationMonitor::turnOn
{
    before(object.measureRadiation);
    contained_by(condition object.window.Available);
	met_by(condition object.state.Off);
	equals(effect object.state.poweringUp);
	meets(effect object.state.On);
}

RadiationMonitor::turnOff
{
    after(object.measureRadiation);
    contained_by(condition object.window.Available);
	met_by(condition object.state.On);
	equals(effect object.state.poweringDown);
	meets(effect object.state.Off);
}

RadiationMonitor::consumePowerWhileOn
{
    contained_by(object.state.On);
    bool continueLoopR;
    if(continueLoopR) {
        meets(effect object.consumePowerWhileOn next);
        next.end <= 70;
        starts(effect object.nanosat.mainBattery.consume power);
        mulEq(duration, 4, power.quantity);
    }
}