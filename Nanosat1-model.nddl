class Nanosatellite;
class Battery;
class PayloadState;
class Window;
class SolarPanel;
class Memory;
class STX;
class C3D;
class TOPCAT;
class MIC;
class FUNCUBE;
class Comms;
class JANUS;
class UVTRX;

class Nanosatellite 
{
	Battery mainBattery;
	Memory memory;
	SolarPanel panel;
	STX stx;
	C3D c3d;
	TOPCAT topcat;
	MIC mic;
	FUNCUBE funcube2;
	JANUS janus;
	UVTRX uvtrx;
	Window saa;
	Window sunlight;
	Window localSunlight;
		    
	Nanosatellite(Battery b, Memory m)
	{
    	mainBattery = b;
    	memory = m;
        panel = new SolarPanel(this);
        stx = new STX(this);
        c3d = new C3D(this);
        topcat = new TOPCAT(this);
        mic = new MIC(this);
        funcube2 = new FUNCUBE(this);
        janus = new JANUS(this);
        uvtrx = new UVTRX(this);
        saa = new Window();
        sunlight = new Window();
        localSunlight = new Window();
  	}
}

class C3D
{
    Nanosatellite nanosat;
    PayloadState state;
    Window window;
    
    C3D(Nanosatellite n)
    {
        nanosat = n;
        state = new PayloadState();
        window = new Window();
    }
    
    action turnOn{
	    eq(1, duration);
	}
	
	action turnOff{
	    eq(1, duration);
	}
	
	action consumePowerWhileOn {
	    eq(1, duration);
	}
	
	action runHouseKeepingModeBeforeCamera {
	    eq(1, duration);
	}
	
	action takePhoto {
	    eq(30, duration);
	}
	
	action runHouseKeepingModeBeforeRM {
	    eq(1, duration);
	}
	
	action measureRadiation {
	    eq(40, duration);
	}
}

class TOPCAT
{
    Nanosatellite nanosat;
    PayloadState state;
    
    TOPCAT(Nanosatellite n)
    {
        nanosat = n;
        state = new PayloadState();
    }
    
    action turnOn{
	    eq(15, duration);
	}
	
	action turnOff{
	    eq(1, duration);
	}
	
	action consumePowerWhileOn {
	    eq(1, duration);
	}
	
	action runExperiment {
	    eq(40, duration);
	}
}

class MIC
{
    Nanosatellite nanosat;
    PayloadState state;
    
    MIC(Nanosatellite n)
    {
        nanosat = n;
        state = new PayloadState();
    }
    
    action turnOn{
	    eq(1, duration);
	}
	
	action turnOff{
	    eq(1, duration);
	}
	
	action consumePowerWhileOn {
	    eq(1, duration);
	}
	
	action runExperiment {
	    eq(15, duration);
	}
}

class FUNCUBE
{
    Nanosatellite nanosat;
    Comms education;
    Comms amateur;
    
    FUNCUBE(Nanosatellite n)
    {
        nanosat = n;
        education = new Comms();
        amateur = new Comms();
    }
    
    action communicateEducation {
        eq(1, duration);
    }
    
    action communicateAmateur {
        eq(1, duration);
    }
}

class Comms
{
    Window window;
    
    Comms()
    {
        window = new Window();
    }
}

class JANUS
{
    Nanosatellite nanosat;
    Window window;
    
    JANUS(Nanosatellite n)
    {
        nanosat = n;
        window = new Window();
    }
    
    action runExperimentLowPower {
        eq(1, duration);
    }
    
    action runExperimentHighPower {
        eq(1, duration);
    }
}

class Battery extends Reservoir
{
    string profileType;
    
    // ic = initial capacity, min, max
	Battery(float ic, float min, float max)
	{
		super(ic, min, max);
		profileType="IncrementalFlowProfile";
	}
}

class Memory extends Reservoir
{
    string profileType;
    
    // ic = initial capacity, min, max
	Memory(float ic, float min, float max)
	{
		super(ic, min, max);
		profileType="IncrementalFlowProfile";
	}
}

// Time window for availability
class Window extends Timeline
{
    predicate Available {}
}

class PayloadState extends Timeline
{
	predicate On {}
	predicate Off {}
	predicate poweringUp {}
	predicate poweringDown {}	
}

class SolarPanel
{
    Nanosatellite nanosat;
	Window window;
	
	SolarPanel(Nanosatellite n)
	{
		nanosat = n;
	    window = new Window();
	}
	
	action chargeBattery {
	    eq(1, duration);
	}
}

class STX
{
    Nanosatellite nanosat;
    Window window;
    
    STX(Nanosatellite n)
    {
        nanosat = n;
        window = new Window();
    }
    
    action downlinkData{
        eq(1, duration);
    }
}

class UVTRX
{
    Nanosatellite nanosat;
    Comms beacon;
    Comms downlink;
    
    UVTRX(Nanosatellite n)
    {
        nanosat = n;
        downlink = new Comms();
        beacon = new Comms();
    }
    
    action downlinkData{
        eq(1, duration);
    }
    
    action beaconActive{
        eq(1, duration);
    }
}

// Actions

C3D::takePhoto
{
    met_by(object.runHouseKeepingModeBeforeCamera);
    contained_by(condition object.state.On);
    starts(effect object.nanosat.memory.produce data);
    eq(data.quantity, 691200);
    // this is to ensure it takes a photo of the ground station
    starts(object.nanosat.uvtrx.downlink.window.Available);
    // taking the photo when not in eclipse
    contained_by(object.nanosat.sunlight.Available);
    // taking the photo when it is daylight locally
    contained_by(object.nanosat.localSunlight.Available);
}

C3D::measureRadiation
{
    contained_by(object.nanosat.saa.Available);
    met_by(object.runHouseKeepingModeBeforeRM);
    contained_by(condition object.state.On);
    starts(effect object.nanosat.memory.produce data);
    eq(data.quantity, 18432);
}

C3D::turnOn
{
    contained_by(condition object.window.Available);
	met_by(condition object.state.Off);
	equals(effect object.state.poweringUp);
	meets(effect object.state.On);
}

C3D::turnOff
{
    contained_by(condition object.window.Available);
	met_by(condition object.state.On);
	equals(effect object.state.poweringDown);
	meets(effect object.state.Off);
}

C3D::consumePowerWhileOn
{
    contained_by(condition object.window.Available);
    contained_by(object.state.On);
    starts(effect object.nanosat.mainBattery.consume power);
    mulEq(duration, 13, power.quantity);
    bool continueLoopC;
    if(continueLoopC) {
        meets(effect object.consumePowerWhileOn next);
        next.end <= 1500;
        starts(effect object.nanosat.mainBattery.consume p);
        mulEq(duration, 13, p.quantity);
    }
}

C3D::runHouseKeepingModeBeforeCamera
{
    meets(object.takePhoto);
    contained_by(condition object.state.On);
    starts(effect object.nanosat.memory.produce data);
    eq(data.quantity, 256);
}

C3D::runHouseKeepingModeBeforeRM
{
    meets(object.measureRadiation);
    contained_by(condition object.state.On);
    starts(effect object.nanosat.memory.produce data);
    eq(data.quantity, 256);
}

TOPCAT::turnOn
{
	met_by(condition object.state.Off);
	equals(effect object.state.poweringUp);
	meets(effect object.state.On);
}

TOPCAT::turnOff
{
	met_by(condition object.state.On);
	equals(effect object.state.poweringDown);
	meets(effect object.state.Off);
}

TOPCAT::consumePowerWhileOn
{
    contained_by(object.state.On);
    starts(effect object.nanosat.mainBattery.consume power);
    mulEq(duration, 29, power.quantity);
    bool continueLoopT;
    if(continueLoopT) {
        meets(effect object.consumePowerWhileOn next);
        next.end <= 1500;
        starts(effect object.nanosat.mainBattery.consume p);
        mulEq(duration, 29, p.quantity);
    }
}

TOPCAT::runExperiment
{
    contained_by(condition object.state.On);
    starts(effect object.nanosat.memory.produce data);
    eq(data.quantity, 204800);
}

MIC::turnOn
{
	met_by(condition object.state.Off);
	equals(effect object.state.poweringUp);
	meets(effect object.state.On);
}

MIC::turnOff
{
	met_by(condition object.state.On);
	equals(effect object.state.poweringDown);
	meets(effect object.state.Off);
}

MIC::consumePowerWhileOn
{
    contained_by(object.state.On);
    starts(effect object.nanosat.mainBattery.consume power);
    mulEq(duration, 63, power.quantity);
    bool continueLoopM;
    if(continueLoopM) {
        meets(effect object.consumePowerWhileOn next);
        next.end <= 1500;
        starts(effect object.nanosat.mainBattery.consume p);
        mulEq(duration, 63, p.quantity);
    }
}

MIC::runExperiment
{
    contained_by(condition object.state.On);
    starts(effect object.nanosat.memory.produce data);
    eq(data.quantity, 34816);
}

FUNCUBE::communicateEducation
{
    contained_by(condition object.education.window.Available);
    starts(effect object.nanosat.mainBattery.consume power);
    mulEq(duration, 22, power.quantity);
    bool continueLoopFE;
    if(continueLoopFE) {
        meets(effect object.communicateEducation next);
        next.end <= 1500;
        starts(effect object.nanosat.mainBattery.consume p);
        mulEq(duration, 22, p.quantity);
    }
}

FUNCUBE::communicateAmateur
{
    contained_by(condition object.amateur.window.Available);
    starts(effect object.nanosat.mainBattery.consume power);
    mulEq(duration, 21, power.quantity);
    bool continueLoopFA;
    if(continueLoopFA) {
        meets(effect object.communicateAmateur next);
        next.end <= 1500;
        starts(effect object.nanosat.mainBattery.consume p);
        mulEq(duration, 21, p.quantity);
    }
}

JANUS::runExperimentLowPower
{
    starts(effect object.nanosat.mainBattery.consume power);
    mulEq(duration, 22, power.quantity);
    bool continueLoopJL;
    if(continueLoopJL) {
        meets(effect object.runExperimentLowPower next);
        next.end <= 1500;
        starts(effect object.nanosat.mainBattery.consume p);
        mulEq(duration, 22, p.quantity);
    }
    starts(effect object.nanosat.memory.produce data);
    eq(data.quantity, 512);
}

JANUS::runExperimentHighPower
{
    starts(effect object.nanosat.mainBattery.consume power);
    mulEq(duration, 120, power.quantity);
    bool continueLoopJH;
    if(continueLoopJH) {
        meets(effect object.runExperimentHighPower next);
        next.end <= 1500;
        starts(effect object.nanosat.mainBattery.consume p);
        mulEq(duration, 120, p.quantity);
    }
    starts(effect object.nanosat.memory.produce data);
    eq(data.quantity, 512);
    // this is to ensure it only starts the experiment in the SAA
    starts(condition object.nanosat.saa.Available);
}

SolarPanel::chargeBattery
{
    contained_by(condition object.nanosat.sunlight.Available);
  	bool continueLoopB;
    if(continueLoopB) {
        meets(effect object.chargeBattery next);
        next.end <= 1500;
        starts(effect object.nanosat.mainBattery.produce power);
        mulEq(duration, 133, power.quantity);
    }
}

STX::downlinkData
{
    contained_by(condition object.window.Available);
    bool continueLoopS;
    if(continueLoopS == true) {
        meets(effect object.downlinkData next);
        next.end <= 1500;
        starts(effect object.nanosat.memory.consume data);
        mulEq(duration, 786432, data.quantity);
        starts(effect object.nanosat.mainBattery.consume consumption);
        mulEq(duration, 453, consumption.quantity);
    }
}

UVTRX::downlinkData
{
    contained_by(condition object.downlink.window.Available);
    bool continueLoopU;
    if(continueLoopU) {
        meets(effect object.downlinkData next);
        next.end <= 1500;
        starts(effect object.nanosat.memory.consume data);
        mulEq(duration, 72000, data.quantity);
        starts(effect object.nanosat.mainBattery.consume consumption);
        mulEq(duration, 35, consumption.quantity);
    }
}

UVTRX::beaconActive
{
    contained_by(condition object.beacon.window.Available);
    bool continueLoopUB;
    if(continueLoopUB) {
        meets(effect object.beaconActive next);
        next.end <= 1500;
        starts(effect object.nanosat.mainBattery.consume consumption);
        mulEq(duration, 0.21, consumption.quantity);
    }
}